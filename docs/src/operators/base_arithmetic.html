<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.operators.base_arithmetic API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.operators.base_arithmetic</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations
from typing import Callable, Union
from src.fractions import Fraction
from ..utilities import number

class ArithmeticOpBase:
    &#34;&#34;&#34;Abstract base class for all arithmetic operations.

    These are objects so they can have derivative methods, but they can be
    used like functions i.e. ArithmeticOpBase(0) can be used like a function
    that takes a number and returns a number, even for higher-order functions
    like map.

    Note that, on construction, these objects will simplify themselves, meaning you
    may not end up with an object of the same type as the one you constructed. The
    returned object will always be a descendant of ArithmeticOpBase and will always
    have the same functionality.

    You can add, subtract, multiply, divide, and exponentiate functions using the
    appropriate operators (e.g. +, *). Doing so will return a new function that 
    combines the two given functions appropriately. You can also add numbers and 
    strings to functions. The strings should be parsable expressions.
    
    Args:
        n (number) : the constant to use in the operation
    &#34;&#34;&#34;
    def __init__(self, n: number):
        self.n: number = n
        self.priority: int = -1 #higher means it should go first

    def __new__(cls, n: number):
        &#34;&#34;&#34;We define this to allow simplification.&#34;&#34;&#34;
        return super(ArithmeticOpBase, cls).__new__(cls)
        
    def f(self, x: number) -&gt; number:
        &#34;&#34;&#34;Returns the result of the function called on x.
        
        Args:
        :   x (number) : the number to pass to the function

        Returns:
        :   res (number) : x combined with self.n in some way based on the specific function
        &#34;&#34;&#34;
        raise NotImplementedError

    def derivative(self) -&gt; str:
        &#34;&#34;&#34;Returns a string form of the derivative of this function.

        Formatted as an expression (i.e. no &#39;f(x) = &#39;) for recursive reasons.
        
        Args:
        :   None

        Returns:
        :   f_prime (str) : the symbolic derivative as a string
        &#34;&#34;&#34;
        return str(self.f_prime())

    def __call__(self, x: number) -&gt; number:
        &#34;&#34;&#34;Allows the object to pretend to be a function. Returns f(x).&#34;&#34;&#34;
        return self.f(x)

    def f_prime(self) -&gt; ArithmeticOpBase:
        &#34;&#34;&#34;Returns a function that returns the instantaneous slope at x.
        
        Args:
        :   None

        Returns:
        :   derivative (ArithmeticBaseOp) : a function that computes the derivative
        &#34;&#34;&#34;
        raise NotImplementedError

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Returns string representation of expression.&#34;&#34;&#34;
        raise NotImplementedError

    def _get_func(self, other: operator_input) -&gt; ArithmeticOpBase:
        &#34;&#34;&#34;Makes the other into an ArithmeticOpBase, if it isn&#39;t already.&#34;&#34;&#34;
        if isinstance(other, ArithmeticOpBase):
            return other
        if isinstance(other, int) or isinstance(other, float) or isinstance(other, Fraction):
            from .arithmetic import const
            return const(other)
        if isinstance(other, str):
            from .parsing import parse_expr
            return parse_expr(other)
        raise ValueError(f&#39;Unexpected argument to function arithmetic: {other}&#39;)

    def _binop(self, other: operator_input, combiner: Callable) -&gt; ArithmeticOpBase:
        &#34;&#34;&#34;Combines self and other using combiner.&#34;&#34;&#34;
        return combiner(self, self._get_func(other))

    def _simple_add(self, other: operator_input) -&gt; simple_return:
        &#34;&#34;&#34;Tries to return simplified self + other. If it can&#39;t, it will return None.&#34;&#34;&#34;
        other = self._get_func(other)
        from .arithmetic import const
        if isinstance(other, const) and other.n == 0:
            return self
        return None

    def _simple_sub(self, other: operator_input) -&gt; simple_return:
        &#34;&#34;&#34;Tries to return simplified self - other. If it can&#39;t, it will return None.&#34;&#34;&#34;
        other = self._get_func(other)
        from .arithmetic import const
        if isinstance(other, const) and other.n == 0:
            return self
        return None

    def _simple_mul(self, other: operator_input) -&gt; simple_return:
        &#34;&#34;&#34;Tries to return simplified self * other. If it can&#39;t, it will return None.&#34;&#34;&#34;
        other = self._get_func(other)
        from .arithmetic import const
        if isinstance(other, const):
            if other.n == 0:
                return const(0)
            if other.n == 1:
                return self
        return None

    def _simple_div(self, other: operator_input) -&gt; simple_return:
        &#34;&#34;&#34;Tries to return simplified self / other. If it can&#39;t, it will return None.&#34;&#34;&#34;
        other = self._get_func(other)
        from .arithmetic import const
        if isinstance(other, const) and other.n == 1:
            return self
        return None

    def _simple_exp(self, other: operator_input) -&gt; simple_return:
        &#34;&#34;&#34;Tries to return simplified self ** other. If it can&#39;t, it will return None.&#34;&#34;&#34;
        other = self._get_func(other)
        from .arithmetic import const
        if isinstance(other, const):
            if other.n == 0:
                return const(1)
            if other.n == 1:
                return self
        return None

    def __add__(self, other: operator_input) -&gt; ArithmeticOpBase: 
        s = self._simple_add(other)
        if s: return s
        from .combos import f_plus_g
        return self._binop(other, f_plus_g)

    def __sub__(self, other: operator_input) -&gt; ArithmeticOpBase:
        s = self._simple_sub(other)
        if s: return s
        from .combos import f_minus_g
        return self._binop(other, f_minus_g)

    def __mul__(self, other: operator_input) -&gt; ArithmeticOpBase:
        s = self._simple_mul(other)
        if s: return s
        from .combos import f_times_g
        return self._binop(other, f_times_g)

    def __truediv__(self, other: operator_input) -&gt; ArithmeticOpBase:
        s = self._simple_div(other)
        if s: return s
        from .combos import f_divided_by_g
        return self._binop(other, f_divided_by_g)

    def __pow__(self, other: operator_input) -&gt; ArithmeticOpBase:
        s = self._simple_exp(other)
        if s: return s
        from .combos import f_raised_to_g
        return self._binop(other, f_raised_to_g)

class _single_arg (ArithmeticOpBase):
    &#34;&#34;&#34;Abstract base class for single-argument functions.&#34;&#34;&#34;
    def __init__(self):
        self.priority: int = 5

    def __new__(cls):
        o = object.__new__(cls)
        o.__init__()
        return o

simple_return = Union[ArithmeticOpBase, None]
operator_input = Union[ArithmeticOpBase, int, float, Fraction, str]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.operators.base_arithmetic.ArithmeticOpBase"><code class="flex name class">
<span>class <span class="ident">ArithmeticOpBase</span></span>
<span>(</span><span>n: number)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base class for all arithmetic operations.</p>
<p>These are objects so they can have derivative methods, but they can be
used like functions i.e. ArithmeticOpBase(0) can be used like a function
that takes a number and returns a number, even for higher-order functions
like map.</p>
<p>Note that, on construction, these objects will simplify themselves, meaning you
may not end up with an object of the same type as the one you constructed. The
returned object will always be a descendant of ArithmeticOpBase and will always
have the same functionality.</p>
<p>You can add, subtract, multiply, divide, and exponentiate functions using the
appropriate operators (e.g. +, *). Doing so will return a new function that
combines the two given functions appropriately. You can also add numbers and
strings to functions. The strings should be parsable expressions.</p>
<h2 id="args">Args</h2>
<p>n (number) : the constant to use in the operation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ArithmeticOpBase:
    &#34;&#34;&#34;Abstract base class for all arithmetic operations.

    These are objects so they can have derivative methods, but they can be
    used like functions i.e. ArithmeticOpBase(0) can be used like a function
    that takes a number and returns a number, even for higher-order functions
    like map.

    Note that, on construction, these objects will simplify themselves, meaning you
    may not end up with an object of the same type as the one you constructed. The
    returned object will always be a descendant of ArithmeticOpBase and will always
    have the same functionality.

    You can add, subtract, multiply, divide, and exponentiate functions using the
    appropriate operators (e.g. +, *). Doing so will return a new function that 
    combines the two given functions appropriately. You can also add numbers and 
    strings to functions. The strings should be parsable expressions.
    
    Args:
        n (number) : the constant to use in the operation
    &#34;&#34;&#34;
    def __init__(self, n: number):
        self.n: number = n
        self.priority: int = -1 #higher means it should go first

    def __new__(cls, n: number):
        &#34;&#34;&#34;We define this to allow simplification.&#34;&#34;&#34;
        return super(ArithmeticOpBase, cls).__new__(cls)
        
    def f(self, x: number) -&gt; number:
        &#34;&#34;&#34;Returns the result of the function called on x.
        
        Args:
        :   x (number) : the number to pass to the function

        Returns:
        :   res (number) : x combined with self.n in some way based on the specific function
        &#34;&#34;&#34;
        raise NotImplementedError

    def derivative(self) -&gt; str:
        &#34;&#34;&#34;Returns a string form of the derivative of this function.

        Formatted as an expression (i.e. no &#39;f(x) = &#39;) for recursive reasons.
        
        Args:
        :   None

        Returns:
        :   f_prime (str) : the symbolic derivative as a string
        &#34;&#34;&#34;
        return str(self.f_prime())

    def __call__(self, x: number) -&gt; number:
        &#34;&#34;&#34;Allows the object to pretend to be a function. Returns f(x).&#34;&#34;&#34;
        return self.f(x)

    def f_prime(self) -&gt; ArithmeticOpBase:
        &#34;&#34;&#34;Returns a function that returns the instantaneous slope at x.
        
        Args:
        :   None

        Returns:
        :   derivative (ArithmeticBaseOp) : a function that computes the derivative
        &#34;&#34;&#34;
        raise NotImplementedError

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Returns string representation of expression.&#34;&#34;&#34;
        raise NotImplementedError

    def _get_func(self, other: operator_input) -&gt; ArithmeticOpBase:
        &#34;&#34;&#34;Makes the other into an ArithmeticOpBase, if it isn&#39;t already.&#34;&#34;&#34;
        if isinstance(other, ArithmeticOpBase):
            return other
        if isinstance(other, int) or isinstance(other, float) or isinstance(other, Fraction):
            from .arithmetic import const
            return const(other)
        if isinstance(other, str):
            from .parsing import parse_expr
            return parse_expr(other)
        raise ValueError(f&#39;Unexpected argument to function arithmetic: {other}&#39;)

    def _binop(self, other: operator_input, combiner: Callable) -&gt; ArithmeticOpBase:
        &#34;&#34;&#34;Combines self and other using combiner.&#34;&#34;&#34;
        return combiner(self, self._get_func(other))

    def _simple_add(self, other: operator_input) -&gt; simple_return:
        &#34;&#34;&#34;Tries to return simplified self + other. If it can&#39;t, it will return None.&#34;&#34;&#34;
        other = self._get_func(other)
        from .arithmetic import const
        if isinstance(other, const) and other.n == 0:
            return self
        return None

    def _simple_sub(self, other: operator_input) -&gt; simple_return:
        &#34;&#34;&#34;Tries to return simplified self - other. If it can&#39;t, it will return None.&#34;&#34;&#34;
        other = self._get_func(other)
        from .arithmetic import const
        if isinstance(other, const) and other.n == 0:
            return self
        return None

    def _simple_mul(self, other: operator_input) -&gt; simple_return:
        &#34;&#34;&#34;Tries to return simplified self * other. If it can&#39;t, it will return None.&#34;&#34;&#34;
        other = self._get_func(other)
        from .arithmetic import const
        if isinstance(other, const):
            if other.n == 0:
                return const(0)
            if other.n == 1:
                return self
        return None

    def _simple_div(self, other: operator_input) -&gt; simple_return:
        &#34;&#34;&#34;Tries to return simplified self / other. If it can&#39;t, it will return None.&#34;&#34;&#34;
        other = self._get_func(other)
        from .arithmetic import const
        if isinstance(other, const) and other.n == 1:
            return self
        return None

    def _simple_exp(self, other: operator_input) -&gt; simple_return:
        &#34;&#34;&#34;Tries to return simplified self ** other. If it can&#39;t, it will return None.&#34;&#34;&#34;
        other = self._get_func(other)
        from .arithmetic import const
        if isinstance(other, const):
            if other.n == 0:
                return const(1)
            if other.n == 1:
                return self
        return None

    def __add__(self, other: operator_input) -&gt; ArithmeticOpBase: 
        s = self._simple_add(other)
        if s: return s
        from .combos import f_plus_g
        return self._binop(other, f_plus_g)

    def __sub__(self, other: operator_input) -&gt; ArithmeticOpBase:
        s = self._simple_sub(other)
        if s: return s
        from .combos import f_minus_g
        return self._binop(other, f_minus_g)

    def __mul__(self, other: operator_input) -&gt; ArithmeticOpBase:
        s = self._simple_mul(other)
        if s: return s
        from .combos import f_times_g
        return self._binop(other, f_times_g)

    def __truediv__(self, other: operator_input) -&gt; ArithmeticOpBase:
        s = self._simple_div(other)
        if s: return s
        from .combos import f_divided_by_g
        return self._binop(other, f_divided_by_g)

    def __pow__(self, other: operator_input) -&gt; ArithmeticOpBase:
        s = self._simple_exp(other)
        if s: return s
        from .combos import f_raised_to_g
        return self._binop(other, f_raised_to_g)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="src.operators.arithmetic.add_n" href="arithmetic.html#src.operators.arithmetic.add_n">add_n</a></li>
<li><a title="src.operators.arithmetic.const" href="arithmetic.html#src.operators.arithmetic.const">const</a></li>
<li><a title="src.operators.arithmetic.div_n" href="arithmetic.html#src.operators.arithmetic.div_n">div_n</a></li>
<li><a title="src.operators.arithmetic.exp_n" href="arithmetic.html#src.operators.arithmetic.exp_n">exp_n</a></li>
<li><a title="src.operators.arithmetic.floordiv_n" href="arithmetic.html#src.operators.arithmetic.floordiv_n">floordiv_n</a></li>
<li><a title="src.operators.arithmetic.log_base_n" href="arithmetic.html#src.operators.arithmetic.log_base_n">log_base_n</a></li>
<li><a title="src.operators.arithmetic.log_of_n" href="arithmetic.html#src.operators.arithmetic.log_of_n">log_of_n</a></li>
<li><a title="src.operators.arithmetic.mult_n" href="arithmetic.html#src.operators.arithmetic.mult_n">mult_n</a></li>
<li><a title="src.operators.arithmetic.n_div" href="arithmetic.html#src.operators.arithmetic.n_div">n_div</a></li>
<li><a title="src.operators.arithmetic.n_exp" href="arithmetic.html#src.operators.arithmetic.n_exp">n_exp</a></li>
<li><a title="src.operators.arithmetic.n_floordiv" href="arithmetic.html#src.operators.arithmetic.n_floordiv">n_floordiv</a></li>
<li><a title="src.operators.arithmetic.n_sub" href="arithmetic.html#src.operators.arithmetic.n_sub">n_sub</a></li>
<li><a title="src.operators.arithmetic.sub_n" href="arithmetic.html#src.operators.arithmetic.sub_n">sub_n</a></li>
<li>src.operators.base_arithmetic._single_arg</li>
<li><a title="src.operators.combos.TwoFunctionsBase" href="combos.html#src.operators.combos.TwoFunctionsBase">TwoFunctionsBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.operators.base_arithmetic.ArithmeticOpBase.derivative"><code class="name flex">
<span>def <span class="ident">derivative</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a string form of the derivative of this function.</p>
<p>Formatted as an expression (i.e. no 'f(x) = ') for recursive reasons.</p>
<dl>
<dt>Args:</dt>
<dd>None</dd>
<dt>Returns:</dt>
<dd>f_prime (str) : the symbolic derivative as a string</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def derivative(self) -&gt; str:
    &#34;&#34;&#34;Returns a string form of the derivative of this function.

    Formatted as an expression (i.e. no &#39;f(x) = &#39;) for recursive reasons.
    
    Args:
    :   None

    Returns:
    :   f_prime (str) : the symbolic derivative as a string
    &#34;&#34;&#34;
    return str(self.f_prime())</code></pre>
</details>
</dd>
<dt id="src.operators.base_arithmetic.ArithmeticOpBase.f"><code class="name flex">
<span>def <span class="ident">f</span></span>(<span>self, x: number) ‑> Union[int, float, <a title="src.fractions.Fraction" href="../fractions.html#src.fractions.Fraction">Fraction</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the result of the function called on x.</p>
<dl>
<dt>Args:</dt>
<dd>x (number) : the number to pass to the function</dd>
<dt>Returns:</dt>
<dd>res (number) : x combined with self.n in some way based on the specific function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f(self, x: number) -&gt; number:
    &#34;&#34;&#34;Returns the result of the function called on x.
    
    Args:
    :   x (number) : the number to pass to the function

    Returns:
    :   res (number) : x combined with self.n in some way based on the specific function
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="src.operators.base_arithmetic.ArithmeticOpBase.f_prime"><code class="name flex">
<span>def <span class="ident">f_prime</span></span>(<span>self) ‑> <a title="src.operators.base_arithmetic.ArithmeticOpBase" href="#src.operators.base_arithmetic.ArithmeticOpBase">ArithmeticOpBase</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a function that returns the instantaneous slope at x.</p>
<dl>
<dt>Args:</dt>
<dd>None</dd>
<dt>Returns:</dt>
<dd>derivative (ArithmeticBaseOp) : a function that computes the derivative</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f_prime(self) -&gt; ArithmeticOpBase:
    &#34;&#34;&#34;Returns a function that returns the instantaneous slope at x.
    
    Args:
    :   None

    Returns:
    :   derivative (ArithmeticBaseOp) : a function that computes the derivative
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.operators" href="index.html">src.operators</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.operators.base_arithmetic.ArithmeticOpBase" href="#src.operators.base_arithmetic.ArithmeticOpBase">ArithmeticOpBase</a></code></h4>
<ul class="">
<li><code><a title="src.operators.base_arithmetic.ArithmeticOpBase.derivative" href="#src.operators.base_arithmetic.ArithmeticOpBase.derivative">derivative</a></code></li>
<li><code><a title="src.operators.base_arithmetic.ArithmeticOpBase.f" href="#src.operators.base_arithmetic.ArithmeticOpBase.f">f</a></code></li>
<li><code><a title="src.operators.base_arithmetic.ArithmeticOpBase.f_prime" href="#src.operators.base_arithmetic.ArithmeticOpBase.f_prime">f_prime</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>